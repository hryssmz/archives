{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Django REST framework \uf0c1 Django REST framework is a powerful and flexible toolkit for building Web APIs. Some reasons you might want to use REST framework: The Web browsable API is a huge usability win for your developers. Authentication policies including packages for OAuth1a and OAuth2 . Serialization that supports both ORM and non-ORM data sources. Customizable all the way down - just use regular function-based views if you don't need the more powerful features . Extensive documentation, and great community support . Used and trusted by internationally recognised companies including Mozilla , Red Hat , Heroku , and Eventbrite . Requirements \uf0c1 REST framework requires the following: Python (3.6, 3.7, 3.8, 3.9, 3.10) Django (2.2, 3.0, 3.1, 3.2, 4.0, 4.1) We highly recommend and only officially support the latest patch release of each Python and Django series. The following packages are optional: PyYAML , uritemplate (5.1+, 3.0.0+) - Schema generation support. Markdown (3.0.0+) - Markdown support for the browsable API. Pygments (2.4.0+) - Add syntax highlighting to Markdown processing. django-filter (1.0.1+) - Filtering support. django-guardian (1.1.1+) - Object level permissions support. Installation \uf0c1 Install using pip , including any optional packages you want... pip install djangorestframework pip install markdown # Markdown support for the browsable API. pip install django-filter # Filtering support ...or clone the project from github. git clone https://github.com/encode/django-rest-framework Add 'rest_framework' to your INSTALLED_APPS setting. INSTALLED_APPS = [ ... 'rest_framework', ] If you're intending to use the browsable API you'll probably also want to add REST framework's login and logout views. Add the following to your root urls.py file. urlpatterns = [ ... path('api-auth/', include('rest_framework.urls')) ] Note that the URL path can be whatever you want. Example \uf0c1 Let's take a look at a quick example of using REST framework to build a simple model-backed API. We'll create a read-write API for accessing information on the users of our project. Any global settings for a REST framework API are kept in a single configuration dictionary named REST_FRAMEWORK . Start off by adding the following to your settings.py module: REST_FRAMEWORK = { # Use Django's standard `django.contrib.auth` permissions, # or allow read-only access for unauthenticated users. 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly' ] } Don't forget to make sure you've also added rest_framework to your INSTALLED_APPS . We're ready to create our API now. Here's our project's root urls.py module: from django.urls import path, include from django.contrib.auth.models import User from rest_framework import routers, serializers, viewsets # Serializers define the API representation. class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ['url', 'username', 'email', 'is_staff'] # ViewSets define the view behavior. class UserViewSet(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializer # Routers provide an easy way of automatically determining the URL conf. router = routers.DefaultRouter() router.register(r'users', UserViewSet) # Wire up our API using automatic URL routing. # Additionally, we include login URLs for the browsable API. urlpatterns = [ path('', include(router.urls)), path('api-auth/', include('rest_framework.urls', namespace='rest_framework')) ] You can now open the API in your browser at http://127.0.0.1:8000/ , and view your new 'users' API. If you use the login control in the top right corner you'll also be able to add, create and delete users from the system. Quickstart \uf0c1 Can't wait to get started? The quickstart guide is the fastest way to get up and running, and building APIs with REST framework. Development \uf0c1 See the Contribution guidelines for information on how to clone the repository, run the test suite and contribute changes back to REST Framework.","title":"Home"},{"location":"index.html#django-rest-framework","text":"Django REST framework is a powerful and flexible toolkit for building Web APIs. Some reasons you might want to use REST framework: The Web browsable API is a huge usability win for your developers. Authentication policies including packages for OAuth1a and OAuth2 . Serialization that supports both ORM and non-ORM data sources. Customizable all the way down - just use regular function-based views if you don't need the more powerful features . Extensive documentation, and great community support . Used and trusted by internationally recognised companies including Mozilla , Red Hat , Heroku , and Eventbrite .","title":"Django REST framework"},{"location":"index.html#requirements","text":"REST framework requires the following: Python (3.6, 3.7, 3.8, 3.9, 3.10) Django (2.2, 3.0, 3.1, 3.2, 4.0, 4.1) We highly recommend and only officially support the latest patch release of each Python and Django series. The following packages are optional: PyYAML , uritemplate (5.1+, 3.0.0+) - Schema generation support. Markdown (3.0.0+) - Markdown support for the browsable API. Pygments (2.4.0+) - Add syntax highlighting to Markdown processing. django-filter (1.0.1+) - Filtering support. django-guardian (1.1.1+) - Object level permissions support.","title":"Requirements"},{"location":"index.html#installation","text":"Install using pip , including any optional packages you want... pip install djangorestframework pip install markdown # Markdown support for the browsable API. pip install django-filter # Filtering support ...or clone the project from github. git clone https://github.com/encode/django-rest-framework Add 'rest_framework' to your INSTALLED_APPS setting. INSTALLED_APPS = [ ... 'rest_framework', ] If you're intending to use the browsable API you'll probably also want to add REST framework's login and logout views. Add the following to your root urls.py file. urlpatterns = [ ... path('api-auth/', include('rest_framework.urls')) ] Note that the URL path can be whatever you want.","title":"Installation"},{"location":"index.html#example","text":"Let's take a look at a quick example of using REST framework to build a simple model-backed API. We'll create a read-write API for accessing information on the users of our project. Any global settings for a REST framework API are kept in a single configuration dictionary named REST_FRAMEWORK . Start off by adding the following to your settings.py module: REST_FRAMEWORK = { # Use Django's standard `django.contrib.auth` permissions, # or allow read-only access for unauthenticated users. 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly' ] } Don't forget to make sure you've also added rest_framework to your INSTALLED_APPS . We're ready to create our API now. Here's our project's root urls.py module: from django.urls import path, include from django.contrib.auth.models import User from rest_framework import routers, serializers, viewsets # Serializers define the API representation. class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ['url', 'username', 'email', 'is_staff'] # ViewSets define the view behavior. class UserViewSet(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializer # Routers provide an easy way of automatically determining the URL conf. router = routers.DefaultRouter() router.register(r'users', UserViewSet) # Wire up our API using automatic URL routing. # Additionally, we include login URLs for the browsable API. urlpatterns = [ path('', include(router.urls)), path('api-auth/', include('rest_framework.urls', namespace='rest_framework')) ] You can now open the API in your browser at http://127.0.0.1:8000/ , and view your new 'users' API. If you use the login control in the top right corner you'll also be able to add, create and delete users from the system.","title":"Example"},{"location":"index.html#quickstart","text":"Can't wait to get started? The quickstart guide is the fastest way to get up and running, and building APIs with REST framework.","title":"Quickstart"},{"location":"index.html#development","text":"See the Contribution guidelines for information on how to clone the repository, run the test suite and contribute changes back to REST Framework.","title":"Development"},{"location":"tutorial/1-serialization.html","text":"Tutorial 1: Serialization \uf0c1 Introduction \uf0c1 This tutorial will cover creating a simple pastebin code highlighting Web API. Along the way it will introduce the various components that make up REST framework, and give you a comprehensive understanding of how everything fits together. The tutorial is fairly in-depth, so you should probably get a cookie and a cup of your favorite brew before getting started. If you just want a quick overview, you should head over to the quickstart documentation instead. Note : The code for this tutorial is available in the encode/rest-framework-tutorial repository on GitHub. The completed implementation is also online as a sandbox version for testing, available here . Setting up a new environment \uf0c1 Before we do anything else we'll create a new virtual environment, using venv . This will make sure our package configuration is kept nicely isolated from any other projects we're working on.","title":"1 - Serialization"},{"location":"tutorial/1-serialization.html#tutorial-1-serialization","text":"","title":"Tutorial 1: Serialization"},{"location":"tutorial/1-serialization.html#introduction","text":"This tutorial will cover creating a simple pastebin code highlighting Web API. Along the way it will introduce the various components that make up REST framework, and give you a comprehensive understanding of how everything fits together. The tutorial is fairly in-depth, so you should probably get a cookie and a cup of your favorite brew before getting started. If you just want a quick overview, you should head over to the quickstart documentation instead. Note : The code for this tutorial is available in the encode/rest-framework-tutorial repository on GitHub. The completed implementation is also online as a sandbox version for testing, available here .","title":"Introduction"},{"location":"tutorial/1-serialization.html#setting-up-a-new-environment","text":"Before we do anything else we'll create a new virtual environment, using venv . This will make sure our package configuration is kept nicely isolated from any other projects we're working on.","title":"Setting up a new environment"},{"location":"tutorial/quickstart.html","text":"Quickstart \uf0c1 We're going to create a simple API to allow admin users to view and edit the users and groups in the system. Project setup \uf0c1 Create a new Django project named tutorial , then start a new app called quickstart . # Create the project directory mkdir tutorial cd tutorial # Create a virtual environment to isolate our package dependencies locally python3 -m venv env source env/bin/activate # On Windows use `env\\Scripts\\activate` # Install Django and Django REST framework into the virtual environment pip install django pip install djangorestframework # Set up a new project with a single application django-admin startproject tutorial . # Note the trailing '.' character cd tutorial django-admin startapp quickstart cd .. The project layout should look like: $ pwd <some path>/tutorial $ find . . ./manage.py ./tutorial ./tutorial/__init__.py ./tutorial/quickstart ./tutorial/quickstart/__init__.py ./tutorial/quickstart/admin.py ./tutorial/quickstart/apps.py ./tutorial/quickstart/migrations ./tutorial/quickstart/migrations/__init__.py ./tutorial/quickstart/models.py ./tutorial/quickstart/tests.py ./tutorial/quickstart/views.py ./tutorial/asgi.py ./tutorial/settings.py ./tutorial/urls.py ./tutorial/wsgi.py It may look unusual that the application has been created within the project directory. Using the project's namespace avoids name clashes with external modules (a topic that goes outside the scope of the quickstart). Now sync your database for the first time: python manage.py migrate We'll also create an initial user named admin with a password of password123 . We'll authenticate as that user later in our example. python manage.py createsuperuser --email admin@example.com --username admin Once you've set up a database and the initial user is created and ready to go, open up the app's directory and we'll get coding... Serializers \uf0c1 First up we're going to define some serializers. Let's create a new module named tutorial/quickstart/serializers.py that we'll use for our data representations. from django.contrib.auth.models import User, Group from rest_framework import serializers class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ['url', 'username', 'email', 'groups'] class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Group fields = ['url', 'name'] Notice that we're using hyperlinked relations in this case with HyperlinkedModelSerializer . You can also use primary key and various other relationships, but hyperlinking is good RESTful design. Views \uf0c1 Right, we'd better write some views then. Open tutorial/quickstart/views.py and get typing. from django.contrib.auth.models import User, Group from rest_framework import viewsets from rest_framework import permissions from tutorial.quickstart.serializers import UserSerializer, GroupSerializer class UserViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows users to be viewed or edited. \"\"\" queryset = User.objects.all().order_by('-date_joined') serializer_class = UserSerializer permission_classes = [permissions.IsAuthenticated] class GroupViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows groups to be viewed or edited. \"\"\" queryset = Group.objects.all() serializer_class = GroupSerializer permission_classes = [permissions.IsAuthenticated] Rather than write multiple views we're grouping together all the common behavior into classes called ViewSets . We can easily break these down into individual views if we need to, but using viewsets keeps the view logic nicely organized as well as being very concise. URLs \uf0c1 Okay, now let's wire up the API URLs. On to tutorial/urls.py ... from django.urls import include, path from rest_framework import routers from tutorial.quickstart import views router = routers.DefaultRouter() router.register(r'users', views.UserViewSet) router.register(r'groups', views.GroupViewSet) # Wire up our API using automatic URL routing. # Additionally, we include login URLs for the browsable API. urlpatterns = [ path('', include(router.urls)), path('api-auth/', include('rest_framework.urls', namespace='rest_framework')) ] Because we're using viewsets instead of views, we can automatically generate the URL conf for our API, by simply registering the viewsets with a router class. Again, if we need more control over the API URLs we can simply drop down to using regular class-based views, and writing the URL conf explicitly. Finally, we're including default login and logout views for use with the browsable API. That's optional, but useful if your API requires authentication and you want to use the browsable API. Pagination \uf0c1 Pagination allows you to control how many objects per page are returned. To enable it add the following lines to tutorial/settings.py REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 10 } Settings \uf0c1 Add 'rest_framework' to INSTALLED_APPS . The settings module will be in tutorial/settings.py INSTALLED_APPS = [ ... 'rest_framework', ] Okay, we're done. Testing our API \uf0c1 We're now ready to test the API we've built. Let's fire up the server from the command line. python manage.py runserver We can now access our API, both from the command-line, using tools like curl ... $ curl -H 'Accept: application/json; indent=4' -u admin:password123 http://127.0.0.1:8000/users/ { \"count\": 2, \"next\": null, \"previous\": null, \"results\": [ { \"email\": \"admin@example.com\", \"groups\": [], \"url\": \"http://127.0.0.1:8000/users/1/\", \"username\": \"admin\" }, ] } Or using the httpie , command line tool... $ http -a admin:password123 http://127.0.0.1:8000/users/ HTTP/1.1 200 OK ... { \"count\": 2, \"next\": null, \"previous\": null, \"results\": [ { \"email\": \"admin@example.com\", \"groups\": [], \"url\": \"http://localhost:8000/users/1/\", \"username\": \"paul\" }, ] } Or directly through the browser, by going to the URL http://127.0.0.1:8000/users/ ... If you're working through the browser, make sure to login using the control in the top right corner. Great, that was easy! If you want to get a more in depth understanding of how REST framework fits together head on over to the tutorial , or start browsing the API guide .","title":"Quickstart"},{"location":"tutorial/quickstart.html#quickstart","text":"We're going to create a simple API to allow admin users to view and edit the users and groups in the system.","title":"Quickstart"},{"location":"tutorial/quickstart.html#project-setup","text":"Create a new Django project named tutorial , then start a new app called quickstart . # Create the project directory mkdir tutorial cd tutorial # Create a virtual environment to isolate our package dependencies locally python3 -m venv env source env/bin/activate # On Windows use `env\\Scripts\\activate` # Install Django and Django REST framework into the virtual environment pip install django pip install djangorestframework # Set up a new project with a single application django-admin startproject tutorial . # Note the trailing '.' character cd tutorial django-admin startapp quickstart cd .. The project layout should look like: $ pwd <some path>/tutorial $ find . . ./manage.py ./tutorial ./tutorial/__init__.py ./tutorial/quickstart ./tutorial/quickstart/__init__.py ./tutorial/quickstart/admin.py ./tutorial/quickstart/apps.py ./tutorial/quickstart/migrations ./tutorial/quickstart/migrations/__init__.py ./tutorial/quickstart/models.py ./tutorial/quickstart/tests.py ./tutorial/quickstart/views.py ./tutorial/asgi.py ./tutorial/settings.py ./tutorial/urls.py ./tutorial/wsgi.py It may look unusual that the application has been created within the project directory. Using the project's namespace avoids name clashes with external modules (a topic that goes outside the scope of the quickstart). Now sync your database for the first time: python manage.py migrate We'll also create an initial user named admin with a password of password123 . We'll authenticate as that user later in our example. python manage.py createsuperuser --email admin@example.com --username admin Once you've set up a database and the initial user is created and ready to go, open up the app's directory and we'll get coding...","title":"Project setup"},{"location":"tutorial/quickstart.html#serializers","text":"First up we're going to define some serializers. Let's create a new module named tutorial/quickstart/serializers.py that we'll use for our data representations. from django.contrib.auth.models import User, Group from rest_framework import serializers class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ['url', 'username', 'email', 'groups'] class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Group fields = ['url', 'name'] Notice that we're using hyperlinked relations in this case with HyperlinkedModelSerializer . You can also use primary key and various other relationships, but hyperlinking is good RESTful design.","title":"Serializers"},{"location":"tutorial/quickstart.html#views","text":"Right, we'd better write some views then. Open tutorial/quickstart/views.py and get typing. from django.contrib.auth.models import User, Group from rest_framework import viewsets from rest_framework import permissions from tutorial.quickstart.serializers import UserSerializer, GroupSerializer class UserViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows users to be viewed or edited. \"\"\" queryset = User.objects.all().order_by('-date_joined') serializer_class = UserSerializer permission_classes = [permissions.IsAuthenticated] class GroupViewSet(viewsets.ModelViewSet): \"\"\" API endpoint that allows groups to be viewed or edited. \"\"\" queryset = Group.objects.all() serializer_class = GroupSerializer permission_classes = [permissions.IsAuthenticated] Rather than write multiple views we're grouping together all the common behavior into classes called ViewSets . We can easily break these down into individual views if we need to, but using viewsets keeps the view logic nicely organized as well as being very concise.","title":"Views"},{"location":"tutorial/quickstart.html#urls","text":"Okay, now let's wire up the API URLs. On to tutorial/urls.py ... from django.urls import include, path from rest_framework import routers from tutorial.quickstart import views router = routers.DefaultRouter() router.register(r'users', views.UserViewSet) router.register(r'groups', views.GroupViewSet) # Wire up our API using automatic URL routing. # Additionally, we include login URLs for the browsable API. urlpatterns = [ path('', include(router.urls)), path('api-auth/', include('rest_framework.urls', namespace='rest_framework')) ] Because we're using viewsets instead of views, we can automatically generate the URL conf for our API, by simply registering the viewsets with a router class. Again, if we need more control over the API URLs we can simply drop down to using regular class-based views, and writing the URL conf explicitly. Finally, we're including default login and logout views for use with the browsable API. That's optional, but useful if your API requires authentication and you want to use the browsable API.","title":"URLs"},{"location":"tutorial/quickstart.html#pagination","text":"Pagination allows you to control how many objects per page are returned. To enable it add the following lines to tutorial/settings.py REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 10 }","title":"Pagination"},{"location":"tutorial/quickstart.html#settings","text":"Add 'rest_framework' to INSTALLED_APPS . The settings module will be in tutorial/settings.py INSTALLED_APPS = [ ... 'rest_framework', ] Okay, we're done.","title":"Settings"},{"location":"tutorial/quickstart.html#testing-our-api","text":"We're now ready to test the API we've built. Let's fire up the server from the command line. python manage.py runserver We can now access our API, both from the command-line, using tools like curl ... $ curl -H 'Accept: application/json; indent=4' -u admin:password123 http://127.0.0.1:8000/users/ { \"count\": 2, \"next\": null, \"previous\": null, \"results\": [ { \"email\": \"admin@example.com\", \"groups\": [], \"url\": \"http://127.0.0.1:8000/users/1/\", \"username\": \"admin\" }, ] } Or using the httpie , command line tool... $ http -a admin:password123 http://127.0.0.1:8000/users/ HTTP/1.1 200 OK ... { \"count\": 2, \"next\": null, \"previous\": null, \"results\": [ { \"email\": \"admin@example.com\", \"groups\": [], \"url\": \"http://localhost:8000/users/1/\", \"username\": \"paul\" }, ] } Or directly through the browser, by going to the URL http://127.0.0.1:8000/users/ ... If you're working through the browser, make sure to login using the control in the top right corner. Great, that was easy! If you want to get a more in depth understanding of how REST framework fits together head on over to the tutorial , or start browsing the API guide .","title":"Testing our API"}]}